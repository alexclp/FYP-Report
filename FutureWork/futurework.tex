Although the system has met the set requirements, there are some weaknesses and areas of improvement before the project can be considered to be "final". This chapter will further detail all the limitations and the ways in which the project can be extended and improved in the future.
\begin{itemize}
    \item \textbf{Scanning cannot be done on the iOS mobile device.}\newline
    In order to use Wi-Fi scanning capabilities on iOS and receive the signal strengths used in positioning, one should use a native framework, called NEHotspotHelper. However, Apple has restricted access to this framework to only a few apps that are part of the use cases that they "support". To get access, users can apply through a questionnaire, which must pass Apple's checks. For this project, several applications for this framework have been made, but the application does not fall into their supported categories. Because of this, scanning had to be done on an external system, in this case a Raspberry Pi that uploads data directly in the database. This has brought overheads on the system because the whole process is slowed down by the communications between all the subsystems. This will be detailed in the next point.
    
    \item \textbf{Connectivity between the scanning system and other sub-systems.}\newline
    The scanning process is very slow, because the mobile applications have to wait for the "turn on" request to be made on the Scanner Switch, then for the Raspberry Pi to detect the changes, and then for the Raspberry Pi to scan, parse \& upload the data. The whole process takes about 10 to 12 seconds, measured from when the first request has been made, to when the results have been received. The overheads are brought by the HTTP requests that have to be made, and scanning and parsing processes which take place on the Raspberry Pi. Ideally, this process could be accelerated if the Scanner Switch would be eliminated, and the connectivity would be made through Bluetooth between the Raspberry Pi and the mobile devices that run the mobile applications. The reason this has approach has not been chosen in the end was affected by the time constraints. Several prototypes that have been unstable have been made using Bluetooth, and it the end the intermediary web application has been chosen because it was the simplest and most stable way at that time.
    
    \item \textbf{Vapor framework is a very early stage framework.}\newline
    This project has taken an experimental approach, given the recent rise of Swift running on servers, unlike the traditional way of running Swift, which is on iOS devices. One of the most popular framework that utilises this is Vapor. Although the community is very helpful, and the performance of this framework is quite good compared to existing frameworks, such as Ruby on Rails, it can be said that some functionalities have not been added yet. Therefore, the framework lacks support for certain features that others have. This can be seen when, for example, making HTTP requests, which runs synchronously, bringing overhead on the server. A future solution would have to migrate from using Vapor to using something that is made for production. Another important limitation has been the lack of a way to automate actions in a web browser. Many other technologies support certain libraries that to do this, such as Selenium for Python. Due to this limitation, the Logic Layer has had to be split into two components: the AR Data Provider and the Positioning \& Path Finding System.
    
    \item \textbf{ARKit+CoreLocation framework is slightly unstable.}\newline
    Due to the implementation of ARKit, the approach used by the framework to place AR objects has a few known issues. When the user is walking, ARKit may sometimes change the positions of the placed objects, because the framework might receive some erroneous data, which then outputs wrong values. After a short distance, for example, the framework might "think" that the user is walking in a different direction that they actually are. Additionally, the location algorithm provides some wrong data as well, which affects the positions of the AR objects as well.
    
    \item \textbf{Optimising fingerprinting localisation.}\newline
    Right now, the positioning is done only in a deterministic way, based on the available data. This does not always work, since some areas may not have data collected. To overcome this issue, a probabilistic mathematical model could be incorporated in order to determine where the user may be. Typically, a Gaussian distribution is used for this, together with data from recorded reference points. 
    
    \item \textbf{Graphical User Interface.}\newline
    The graphical user interface (GUI\nomenclature{GUI}{Graphical User Interface}) has been designed so that it would be as simple, clear and usable as possible. However, a more attractive GUI should be developed in order to attract more users. These improvements could change the way that the navigation path is shown on the floor plan, or the inclusion of a set of turn-by-turn instructions. Other improvements could be made in the admin application, where more visual cues would greatly improve the experience of the admin user. Overall, the GUI improvements should make users more eager to use the system, and overall improve the quality of the software developed.
    
    \item \textbf{Extending the solution to support more than one building.}\newline
    The solution developed had in mind to only support Bush House. However, the positioning and navigation algorithms have been developed independent from location. Therefore, any building could be supported, as long as the system is slightly changed. The changes that need to be made are: create a Building entity and the possibility to upload floor plans for it, assigns Rooms to Buildings, and then a way to change the values of the corners of the floor plans of a building in latitude and longitude (this can be added to the Building entity).
    
    \item \textbf{Navigation from floor to floor.}\newline
    The navigation algorithm is capable of producing a path as long there are connections between the locations. Therefore, if the locations between floors are connected, a path will be produced between them. However, the current design of the mobile apps makes it makes it impossible to connect two locations that are on different floors, because one floor plan is shown at a time. On the other hand, the app continuously scans for location changes, and the possible destinations that are shown are from the same floor. Thus, if the user changes floors, the corresponding floor plan will be shown, along with the reachable destinations on the same floor. To support navigation between floors in the future, the visual design needs to be changed. One possible solution would incorporate connecting two floors by choosing a room that is the connecting point, e.g. the lift or the stairs.
    
\end{itemize}